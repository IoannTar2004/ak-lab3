# Лабораторная работа №3 по Архитектуре Компьютера

- Тарасов Иван Сергеевич. P3230
- `asm | acc | harv | hw | tick | struct | trap | port | cstr | prob2 | spi`
- Усложнённый вариант

## Язык программирования - Assembly
```
program ::= { line }

line ::= label [ comment ] "\n"
       | instr [ comment ] "\n"
       | [ comment ] "\n"

label ::= label_name ":"

instr ::= op0
        | op1 integer
        | op1 char
        | op1 address
        | op2 address
        | op3 arg
        | op4 label_name

op0 ::= "inc"
      | "dec"
      | "halt"
      | "ei"
      | "di"
      | "pop"
      | "push"
      | "ret"
      | "iret"

op1 ::= | "store"
        | "add"
        | "sub"
        | "mul"
        | "div"
        | "rem"
        | "cmp"
   
op2 ::= "store"
      
op3 ::= "in"
      | "out"
      | "timer"
      | "clk"
      | "sign"

op4 ::= "jmp"
      | "je"
      | "jne"
      | "jge"
      | "int"
      | "call"

integer ::= [ "-" ] { <any of "0-9"> }-

char ::= '<"a-z A-z">'

address ::= <any of *> { <any of "0-9"> }

arg ::= <any of "0-9">

label_name ::= <any of "a-z A-Z _"> { <any of "a-z A-Z 0-9 _"> }

comment ::= ";" <any symbols except "\n">
```
**Операции:**

_Операции с памятью:_
- `load` - загружает в аккумулятор указанное в аргументе число или значение из указанной ячейки памяти
- `store` - сохраняет в память значение из аккумулятора по указанной ячейке памяти

_Арифметические операции (результат записывается в аккумулятор):_
- `add` - произвести сложение аккумулятора с указанным числом или значением из указанной ячейки памяти
- `sub` - произвести вычитание указанного числа или значения из указанной ячейки памяти из аккумулятора
- `mul` - произвести умножение аккумулятора на указанное число или значение из указанной ячейки памяти
- `div` - произвести деление аккумулятора на указанное число или значение из указанной ячейки памяти
- `rem` - вычисление остатка от деления аккумулятора на указанное число или значение из указанной ячейки памяти
- `inc` - инкремент аккумулятора
- `dec` - декремент аккумулятора
- `cmp` - установить флаги по вычитанию указанного числа или значения из указанной ячейки памяти из аккумулятора

_Инструкции перехода_:
- `jmp` - безусловный переход на метку
- `je` - переход на метку, если флаг 'Z' равен 1.
- `jne` - переход на метку, если флаг 'Z' равен 0.
- `jge` - переход на метку, если флаг 'N' равен 0.

_Инструкции подпрограмм_:
- `call` - переход на подпрограмму. Добавление в стек адреса возврата из подпрограммы
- `ret` - возврат из подпрограммы. Восстановление IP из стека
- `iret` - возврат из прерывания. Восстановление аккумулятора и IP. Разрешение прерываний

_Инструкции настройки прерываний:_
- `ei` - разрешить прерывания (включить таймер прерываний)
- `di` - запретить прерывания (выключить таймер прерываний)
- `int` - назначить обработчик прерывания
- `timer` - установить задержку для таймера прерываний

_Операции со стеком:_
- `push` - записать в стек значение аккумулятора
- `pop` - записать в аккумулятор значение из вершины стека

_Операции ввода-вывода:_
- `in` - настроить порт, адрес которого указан в аргументе, на ввод
- `out` - настроить порт, адрес которого указан в аргументе, на вывод
- `clk` - подать тактовый импульс на порт, адрес которого указан в аргументе,
- `sign` - подать сигнал на порт, адрес которого указан в аргументе. В качестве сигнала выступает значение
аккумулятора (0 или 1)

В файле [isa.py](https://github.com/IoannTar2004/ak-lab3/blob/main/machine/isa.py) указана инструкция "isr",
которая совершает переход на подпрограмму обработки прерывания. Теоретически она может использоваться как
инструкция, однако это бессмысленно. Я добавил ее, чтобы не усложнять код.

**Адресация**

Операции с памятью и арифметические операции поддерживают 4 типа адресации. 
1. <ins>Прямая загрузка</ins>: **instr 10**. Значением выступает просто константа, указанная в 
аргументе инструкции.
   - **load 10** - загружает в аккумулятор число 10. 
   - **add 10** - производит сложение аккумулятора с числом 10.
2. <ins>Абсолютная адресация</ins>: **instr \*10**. Значением выступает содержимое из ячейки памяти, 
указанной после символа \*.
   - **load \*10** - загружает в аккумулятор значение из 10-ой ячейки памяти. 
   - **add \*10** - производит сложение аккумулятора со значением из 10-ой ячейки.
3. <ins>Косвенная адресация</ins>: **instr \*\*10**. Значением выступает содержимое ячейки памяти, 
указатель которой лежит в другой ячейке, указанная после звездочек. Можно указывать больше двух звездочек, 
тем самым, наращивая уровень косвенности.
   - **load \*\*10** - загружает в аккумулятор значение из ячейки памяти, указатель которой 
    находится в ячейке 10. 
   - **add \*\*10** - производит сложение аккумулятора со значением из ячейки памяти, указатель которой 
    находится в ячейке 10. 
4. <ins>Косвенная автоинкрементая адресация</ins>: **instr \*\*10+**. Работает также, как и косвенная 
адресация, но после получения содержимого ячейки инкрементирует указатель, лежащий в указанной в аргументе 
ячейке. Используется для реализации автоматического указателя.
   - **load \*\*10+** - загружает в аккумулятор значение из ячейки памяти, указатель которой 
   находится в ячейке 10, инкрементируя указатель в 10-ой ячейке. 
   - **add \*\*10+** - производит сложение аккумулятора со значением из ячейки памяти, указатель которой 
   находится в ячейке 10, инкрементируя указатель в 10-ой ячейке.

Инструкция "store" не поддерживает прямую загрузку!

Метки для переходов могут определяться как на отдельных строчках, так и слева от инструкци:
```
label: load 0

label:
   load 0
```

На этапе трансляции в инструкции перехода, а также в инструкции "int" и "call", вместо меток подставляются
указатель на инструкции в памяти команд.

```jmp label ; -> jmp 10```