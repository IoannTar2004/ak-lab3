transfer:
    out 2           ; загрузка старшего бита аккумулятора в буфер вывода
    sign 0          ; сдвиг влево на 1 бит аккумулятора и регистра данных в slave, если sclk = 1
    in 1            ; загрузка бита из буфера ввода в младший бит аккумулятора
    store *3        ; сохранение результата передачи
    iret

print:
    movh                ; смещаю младший байт [7:0] в старший байт [31:24]
    store *3            ; сохраняю передаваемый байт в ячейку 2
    load 16             ; счётчик прерываний для передачи 8-ми битов
    store *4

    sign 3              ; CS = 0
    ei
    char:
        load *3         ; загружаю передаваемый символ. После этой инструкции по таймеру происходит прерывание
        load *4
        dec             ; декремент счетчика
        store *4
        jne char
    di
    sign 3              ; CS = 1
    load *3
    cmp 0               ; если приходит 0 со slave, значит все введенные символы переданы, и их больше не нужно сохранять в память
    je skip
    store **2+

    skip: ret

enter_hello:
    load 'H'
    store *5

    load 'e'
    store *6

    load 'l'
    store *7

    load 'l'
    store *8

    load 'o'
    store *9

    load ','
    store *10

    load ' '
    store *11

    ret

_start:
    vec                 ; вектор прерывания - 0 (в аккумуляторе изначально значение 0)
    func transfer       ; устанавливаю функцию transfer как обработчик прерывания
    store *0
    timer 7             ; установка таймера с задержкой в 7 тактов
    sign 3

    call enter_hello    ; сохраняю строку Hello,

    load 5
    store *1            ; сохраняю указатель на текущий символ вывода
    load 12
    store *2            ; сохраняю указатель на первый введенный символ

    load **1+
    loop:
        call print
        load **1+       ; загружаю каждый символ из строки
        cmp 0           ; пока не закончились символы, считываю данные с spi, затем добавляю этот символ в буфер вывода
        jne loop
    call print          ; передаю 0-терминатор в буфер
    end: halt